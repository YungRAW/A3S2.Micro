
ceas.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000846  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000001e  00800060  00000846  000008da  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000004  0080007e  0080007e  000008f8  2**0
                  ALLOC
  3 .debug_aranges 00000040  00000000  00000000  000008f8  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 000000d2  00000000  00000000  00000938  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000587  00000000  00000000  00000a0a  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 0000028d  00000000  00000000  00000f91  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000008a1  00000000  00000000  0000121e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000100  00000000  00000000  00001ac0  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000021c  00000000  00000000  00001bc0  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000034c  00000000  00000000  00001ddc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000048  00000000  00000000  00002128  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d4 e0       	ldi	r29, 0x04	; 4
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e6 e4       	ldi	r30, 0x46	; 70
  68:	f8 e0       	ldi	r31, 0x08	; 8
  6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
  70:	ae 37       	cpi	r26, 0x7E	; 126
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
  76:	10 e0       	ldi	r17, 0x00	; 0
  78:	ae e7       	ldi	r26, 0x7E	; 126
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a2 38       	cpi	r26, 0x82	; 130
  82:	b1 07       	cpc	r27, r17
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 49 00 	call	0x92	; 0x92 <main>
  8a:	0c 94 21 04 	jmp	0x842	; 0x842 <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <main>:
#define FIRST_A_PRESS 2
#define SECOND_A_PRESS 3
#define FIRST_B_PRESS 4
#define SECOND_B_PRESS 5

int main(){
  92:	2f 92       	push	r2
  94:	3f 92       	push	r3
  96:	4f 92       	push	r4
  98:	5f 92       	push	r5
  9a:	6f 92       	push	r6
  9c:	7f 92       	push	r7
  9e:	8f 92       	push	r8
  a0:	9f 92       	push	r9
  a2:	af 92       	push	r10
  a4:	bf 92       	push	r11
  a6:	cf 92       	push	r12
  a8:	df 92       	push	r13
  aa:	ef 92       	push	r14
  ac:	ff 92       	push	r15
  ae:	0f 93       	push	r16
  b0:	1f 93       	push	r17
  b2:	df 93       	push	r29
  b4:	cf 93       	push	r28
  b6:	00 d0       	rcall	.+0      	; 0xb8 <main+0x26>
  b8:	00 d0       	rcall	.+0      	; 0xba <main+0x28>
  ba:	0f 92       	push	r0
  bc:	cd b7       	in	r28, 0x3d	; 61
  be:	de b7       	in	r29, 0x3e	; 62
   unsigned int right_minutes = 0; //valoarea minutului din partea dreapta
   unsigned int right_hours = 0; //valoarea orei din partea dreapta 
   
   char stare = STANDARD_MODE;

   sysinit();
  c0:	0e 94 a8 02 	call	0x550	; 0x550 <sysinit>

   //bit 7 - FOC2 nu se programeaza, ramne 0
   //bits 3,6 - WGM21 si WGM20 = 10, adica mod CTC
   //bits 5:4 - COM21 si COM20 nu se programeaza, raman 0
   //bits 2:0 - CS22, CS21 si CS20 = 110, adica clk/256 (de la prescaler)
   TCCR2 = 0b00001110;
  c4:	8e e0       	ldi	r24, 0x0E	; 14
  c6:	85 bd       	out	0x25, r24	; 37

   //numarator modulo 250
   OCR2 = 250 - 1; //N = 250
  c8:	89 ef       	ldi	r24, 0xF9	; 249
  ca:	83 bd       	out	0x23, r24	; 35
  cc:	66 24       	eor	r6, r6
  ce:	77 24       	eor	r7, r7
  d0:	1d 82       	std	Y+5, r1	; 0x05
  d2:	1c 82       	std	Y+4, r1	; 0x04
  d4:	aa 24       	eor	r10, r10
  d6:	bb 24       	eor	r11, r11
  d8:	44 24       	eor	r4, r4
  da:	55 24       	eor	r5, r5
  dc:	81 e0       	ldi	r24, 0x01	; 1
  de:	8a 83       	std	Y+2, r24	; 0x02
  e0:	1f e7       	ldi	r17, 0x7F	; 127
  e2:	00 e0       	ldi	r16, 0x00	; 0
  e4:	1b 82       	std	Y+3, r1	; 0x03
  e6:	22 24       	eor	r2, r2
  e8:	33 24       	eor	r3, r3
  ea:	88 24       	eor	r8, r8
  ec:	99 24       	eor	r9, r9
  ee:	98 e3       	ldi	r25, 0x38	; 56
  f0:	c9 2e       	mov	r12, r25
  f2:	d1 2c       	mov	r13, r1
  f4:	88 e0       	ldi	r24, 0x08	; 8
  f6:	e8 2e       	mov	r14, r24
  f8:	f1 2c       	mov	r15, r1
  fa:	09 c0       	rjmp	.+18     	; 0x10e <main+0x7c>
  fc:	92 e0       	ldi	r25, 0x02	; 2
  fe:	63 c1       	rjmp	.+710    	; 0x3c6 <main+0x334>
 100:	e1 e0       	ldi	r30, 0x01	; 1
 102:	ea 83       	std	Y+2, r30	; 0x02
 104:	00 e0       	ldi	r16, 0x00	; 0
         putchLCD(kbcode);
      }       //……       
      
      //PORTB &= 0<<1;

      loop_cnt++;
 106:	fb 81       	ldd	r31, Y+3	; 0x03
 108:	ff 5f       	subi	r31, 0xFF	; 255
 10a:	fb 83       	std	Y+3, r31	; 0x03
 10c:	19 81       	ldd	r17, Y+1	; 0x01
   //numarator modulo 250
   OCR2 = 250 - 1; //N = 250

   while(1){  //bucla principala

      if(loop_cnt==DELAY){ //citirile se fac din 15 ms in 15 ms
 10e:	8b 81       	ldd	r24, Y+3	; 0x03
 110:	88 3c       	cpi	r24, 0xC8	; 200
 112:	51 f4       	brne	.+20     	; 0x128 <main+0x96>
         loop_cnt=0; 
 
         code_ante = code_now;
         code_now  = kbscan();
 114:	0e 94 7d 03 	call	0x6fa	; 0x6fa <kbscan>
 118:	89 83       	std	Y+1, r24	; 0x01

         if( code_ante == NOKEY && code_now != NOKEY){
 11a:	1f 37       	cpi	r17, 0x7F	; 127
 11c:	19 f4       	brne	.+6      	; 0x124 <main+0x92>
 11e:	8f 37       	cpi	r24, 0x7F	; 127
 120:	09 f0       	breq	.+2      	; 0x124 <main+0x92>
 122:	9c c1       	rjmp	.+824    	; 0x45c <main+0x3ca>
 124:	19 81       	ldd	r17, Y+1	; 0x01
 126:	1b 82       	std	Y+3, r1	; 0x03
 128:	19 83       	std	Y+1, r17	; 0x01
      
      //PORTB &= 0<<1;

      loop_cnt++;
	  
	  switch(stare){
 12a:	9a 81       	ldd	r25, Y+2	; 0x02
 12c:	93 30       	cpi	r25, 0x03	; 3
 12e:	09 f4       	brne	.+2      	; 0x132 <main+0xa0>
 130:	21 c1       	rjmp	.+578    	; 0x374 <main+0x2e2>
 132:	94 30       	cpi	r25, 0x04	; 4
 134:	28 f4       	brcc	.+10     	; 0x140 <main+0xae>
 136:	91 30       	cpi	r25, 0x01	; 1
 138:	51 f0       	breq	.+20     	; 0x14e <main+0xbc>
 13a:	92 30       	cpi	r25, 0x02	; 2
 13c:	21 f7       	brne	.-56     	; 0x106 <main+0x74>
 13e:	a5 c0       	rjmp	.+330    	; 0x28a <main+0x1f8>
 140:	ea 81       	ldd	r30, Y+2	; 0x02
 142:	e4 30       	cpi	r30, 0x04	; 4
 144:	09 f4       	brne	.+2      	; 0x148 <main+0xb6>
 146:	d3 c0       	rjmp	.+422    	; 0x2ee <main+0x25c>
 148:	e5 30       	cpi	r30, 0x05	; 5
 14a:	e9 f6       	brne	.-70     	; 0x106 <main+0x74>
 14c:	3e c1       	rjmp	.+636    	; 0x3ca <main+0x338>
		  case STANDARD_MODE:
			if(TIFR & 1<<OCF2){
 14e:	08 b6       	in	r0, 0x38	; 56
 150:	07 fe       	sbrs	r0, 7
 152:	97 c0       	rjmp	.+302    	; 0x282 <main+0x1f0>

				TIFR |= 1<<OCF2;
 154:	88 b7       	in	r24, 0x38	; 56
 156:	80 68       	ori	r24, 0x80	; 128
 158:	88 bf       	out	0x38, r24	; 56
				cycles++;
 15a:	08 94       	sec
 15c:	21 1c       	adc	r2, r1
 15e:	31 1c       	adc	r3, r1
	
				if(cycles == 62){ //k/2
 160:	fe e3       	ldi	r31, 0x3E	; 62
 162:	2f 16       	cp	r2, r31
 164:	31 04       	cpc	r3, r1
 166:	79 f4       	brne	.+30     	; 0x186 <main+0xf4>
					gotoLC(2,3);
 168:	82 e0       	ldi	r24, 0x02	; 2
 16a:	63 e0       	ldi	r22, 0x03	; 3
 16c:	0e 94 e1 02 	call	0x5c2	; 0x5c2 <gotoLC>
					putchLCD(32);
 170:	80 e2       	ldi	r24, 0x20	; 32
 172:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <putchLCD>
					gotoLC(2,6);
 176:	82 e0       	ldi	r24, 0x02	; 2
 178:	66 e0       	ldi	r22, 0x06	; 6
 17a:	0e 94 e1 02 	call	0x5c2	; 0x5c2 <gotoLC>
					putchLCD(32);
 17e:	80 e2       	ldi	r24, 0x20	; 32
 180:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <putchLCD>
 184:	7e c0       	rjmp	.+252    	; 0x282 <main+0x1f0>
				}
		
				if(cycles == 125){ //k = 125
 186:	8d e7       	ldi	r24, 0x7D	; 125
 188:	28 16       	cp	r2, r24
 18a:	31 04       	cpc	r3, r1
 18c:	09 f0       	breq	.+2      	; 0x190 <main+0xfe>
 18e:	79 c0       	rjmp	.+242    	; 0x282 <main+0x1f0>
					cycles = 0;
					seconds++;
 190:	08 94       	sec
 192:	81 1c       	adc	r8, r1
 194:	91 1c       	adc	r9, r1
		
					if(seconds > 59){
 196:	9c e3       	ldi	r25, 0x3C	; 60
 198:	89 16       	cp	r8, r25
 19a:	91 04       	cpc	r9, r1
 19c:	28 f0       	brcs	.+10     	; 0x1a8 <main+0x116>
						seconds = 0;
						minutes++;
 19e:	08 94       	sec
 1a0:	c1 1c       	adc	r12, r1
 1a2:	d1 1c       	adc	r13, r1
 1a4:	88 24       	eor	r8, r8
 1a6:	99 24       	eor	r9, r9
					}
		
					if(minutes > 59){
 1a8:	ec e3       	ldi	r30, 0x3C	; 60
 1aa:	ce 16       	cp	r12, r30
 1ac:	d1 04       	cpc	r13, r1
 1ae:	28 f0       	brcs	.+10     	; 0x1ba <main+0x128>
						minutes = 0;
						hours++;
 1b0:	08 94       	sec
 1b2:	e1 1c       	adc	r14, r1
 1b4:	f1 1c       	adc	r15, r1
 1b6:	cc 24       	eor	r12, r12
 1b8:	dd 24       	eor	r13, r13
					}
		
					if(hours > 23){
 1ba:	f8 e1       	ldi	r31, 0x18	; 24
 1bc:	ef 16       	cp	r14, r31
 1be:	f1 04       	cpc	r15, r1
 1c0:	10 f0       	brcs	.+4      	; 0x1c6 <main+0x134>
 1c2:	ee 24       	eor	r14, r14
 1c4:	ff 24       	eor	r15, r15
						hours = 0;
					}
		
					gotoLC(2,1); //seteaza cursorul pe linia 2, coloana 1 
 1c6:	82 e0       	ldi	r24, 0x02	; 2
 1c8:	61 e0       	ldi	r22, 0x01	; 1
 1ca:	0e 94 e1 02 	call	0x5c2	; 0x5c2 <gotoLC>
		
					left_hours = hours / 10;
 1ce:	c7 01       	movw	r24, r14
 1d0:	6a e0       	ldi	r22, 0x0A	; 10
 1d2:	70 e0       	ldi	r23, 0x00	; 0
 1d4:	0e 94 0d 04 	call	0x81a	; 0x81a <__udivmodhi4>
 1d8:	7d 83       	std	Y+5, r23	; 0x05
 1da:	6c 83       	std	Y+4, r22	; 0x04
					
					if(left_hours == 0){
 1dc:	61 15       	cp	r22, r1
 1de:	71 05       	cpc	r23, r1
 1e0:	21 f4       	brne	.+8      	; 0x1ea <main+0x158>
 1e2:	8a e0       	ldi	r24, 0x0A	; 10
 1e4:	90 e0       	ldi	r25, 0x00	; 0
 1e6:	9d 83       	std	Y+5, r25	; 0x05
 1e8:	8c 83       	std	Y+4, r24	; 0x04
						left_hours = SPACE_CHARACTER;
					}
					
					right_hours = hours % 10;
 1ea:	c7 01       	movw	r24, r14
 1ec:	6a e0       	ldi	r22, 0x0A	; 10
 1ee:	70 e0       	ldi	r23, 0x00	; 0
 1f0:	0e 94 0d 04 	call	0x81a	; 0x81a <__udivmodhi4>
 1f4:	2c 01       	movw	r4, r24
					putchLCD( int_to_char(left_hours) );
 1f6:	8c 81       	ldd	r24, Y+4	; 0x04
 1f8:	9d 81       	ldd	r25, Y+5	; 0x05
 1fa:	0e 94 db 03 	call	0x7b6	; 0x7b6 <int_to_char>
 1fe:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <putchLCD>
					putchLCD( int_to_char(right_hours) );
 202:	c2 01       	movw	r24, r4
 204:	0e 94 db 03 	call	0x7b6	; 0x7b6 <int_to_char>
 208:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <putchLCD>
					putchLCD(':');
 20c:	8a e3       	ldi	r24, 0x3A	; 58
 20e:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <putchLCD>
		
					left_minutes = minutes / 10;
 212:	c6 01       	movw	r24, r12
 214:	6a e0       	ldi	r22, 0x0A	; 10
 216:	70 e0       	ldi	r23, 0x00	; 0
 218:	0e 94 0d 04 	call	0x81a	; 0x81a <__udivmodhi4>
 21c:	3b 01       	movw	r6, r22
					right_minutes = minutes % 10;
 21e:	c6 01       	movw	r24, r12
 220:	6a e0       	ldi	r22, 0x0A	; 10
 222:	70 e0       	ldi	r23, 0x00	; 0
 224:	0e 94 0d 04 	call	0x81a	; 0x81a <__udivmodhi4>
 228:	5c 01       	movw	r10, r24
		
					putchLCD( int_to_char(left_minutes) );
 22a:	c3 01       	movw	r24, r6
 22c:	0e 94 db 03 	call	0x7b6	; 0x7b6 <int_to_char>
 230:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <putchLCD>
					putchLCD( int_to_char(right_minutes) );
 234:	c5 01       	movw	r24, r10
 236:	0e 94 db 03 	call	0x7b6	; 0x7b6 <int_to_char>
 23a:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <putchLCD>
					putchLCD(':');
 23e:	8a e3       	ldi	r24, 0x3A	; 58
 240:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <putchLCD>
		
					left_seconds = seconds / 10;
					right_seconds = seconds % 10;
					
					putchLCD( int_to_char(left_seconds) );
 244:	c4 01       	movw	r24, r8
 246:	6a e0       	ldi	r22, 0x0A	; 10
 248:	70 e0       	ldi	r23, 0x00	; 0
 24a:	0e 94 0d 04 	call	0x81a	; 0x81a <__udivmodhi4>
 24e:	cb 01       	movw	r24, r22
 250:	0e 94 db 03 	call	0x7b6	; 0x7b6 <int_to_char>
 254:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <putchLCD>
					putchLCD( int_to_char(right_seconds) );
 258:	c4 01       	movw	r24, r8
 25a:	6a e0       	ldi	r22, 0x0A	; 10
 25c:	70 e0       	ldi	r23, 0x00	; 0
 25e:	0e 94 0d 04 	call	0x81a	; 0x81a <__udivmodhi4>
 262:	0e 94 db 03 	call	0x7b6	; 0x7b6 <int_to_char>
 266:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <putchLCD>
		
					if(TIFR & 1<<OCF2){
 26a:	08 b6       	in	r0, 0x38	; 56
 26c:	07 fe       	sbrs	r0, 7
 26e:	07 c0       	rjmp	.+14     	; 0x27e <main+0x1ec>
						clrLCD();
 270:	0e 94 da 02 	call	0x5b4	; 0x5b4 <clrLCD>
						putsLCD("Eroare ceas!");
 274:	80 e6       	ldi	r24, 0x60	; 96
 276:	90 e0       	ldi	r25, 0x00	; 0
 278:	0e 94 1b 03 	call	0x636	; 0x636 <putsLCD>
 27c:	ff cf       	rjmp	.-2      	; 0x27c <main+0x1ea>
 27e:	22 24       	eor	r2, r2
 280:	33 24       	eor	r3, r3
						while(1){}
					}
				}
			}

         if(kbcode == 'A'){
 282:	01 34       	cpi	r16, 0x41	; 65
 284:	09 f0       	breq	.+2      	; 0x288 <main+0x1f6>
 286:	3f cf       	rjmp	.-386    	; 0x106 <main+0x74>
 288:	39 cf       	rjmp	.-398    	; 0xfc <main+0x6a>
			break;
		
		  case FIRST_A_PRESS:
			seconds = 0;
			
			gotoLC(2,1);
 28a:	82 e0       	ldi	r24, 0x02	; 2
 28c:	61 e0       	ldi	r22, 0x01	; 1
 28e:	0e 94 e1 02 	call	0x5c2	; 0x5c2 <gotoLC>
			putchLCD( int_to_char(left_hours) );
 292:	8c 81       	ldd	r24, Y+4	; 0x04
 294:	9d 81       	ldd	r25, Y+5	; 0x05
 296:	0e 94 db 03 	call	0x7b6	; 0x7b6 <int_to_char>
 29a:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <putchLCD>
			putchLCD( int_to_char(right_hours) );
 29e:	c2 01       	movw	r24, r4
 2a0:	0e 94 db 03 	call	0x7b6	; 0x7b6 <int_to_char>
 2a4:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <putchLCD>
			putchLCD(':');
 2a8:	8a e3       	ldi	r24, 0x3A	; 58
 2aa:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <putchLCD>
			
			putchLCD( int_to_char(left_minutes) );
 2ae:	c3 01       	movw	r24, r6
 2b0:	0e 94 db 03 	call	0x7b6	; 0x7b6 <int_to_char>
 2b4:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <putchLCD>
			putchLCD( int_to_char(right_minutes) );
 2b8:	c5 01       	movw	r24, r10
 2ba:	0e 94 db 03 	call	0x7b6	; 0x7b6 <int_to_char>
 2be:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <putchLCD>
			putchLCD(':');
 2c2:	8a e3       	ldi	r24, 0x3A	; 58
 2c4:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <putchLCD>
			
			putchLCD('0');
 2c8:	80 e3       	ldi	r24, 0x30	; 48
 2ca:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <putchLCD>
			putchLCD('0');
 2ce:	80 e3       	ldi	r24, 0x30	; 48
 2d0:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <putchLCD>
			
			if(kbcode == 'B'){
 2d4:	02 34       	cpi	r16, 0x42	; 66
 2d6:	19 f4       	brne	.+6      	; 0x2de <main+0x24c>
 2d8:	94 e0       	ldi	r25, 0x04	; 4
 2da:	9a 83       	std	Y+2, r25	; 0x02
 2dc:	04 c0       	rjmp	.+8      	; 0x2e6 <main+0x254>
				stare = FIRST_B_PRESS;
            kbcode = 0;
			}
			
			if(kbcode == 'A'){
 2de:	01 34       	cpi	r16, 0x41	; 65
 2e0:	19 f4       	brne	.+6      	; 0x2e8 <main+0x256>
 2e2:	e3 e0       	ldi	r30, 0x03	; 3
 2e4:	ea 83       	std	Y+2, r30	; 0x02
 2e6:	00 e0       	ldi	r16, 0x00	; 0
 2e8:	88 24       	eor	r8, r8
 2ea:	99 24       	eor	r9, r9
 2ec:	0c cf       	rjmp	.-488    	; 0x106 <main+0x74>
            kbcode = 0;
			}
			break;
			
		  case FIRST_B_PRESS:
			minutes++;
 2ee:	08 94       	sec
 2f0:	c1 1c       	adc	r12, r1
 2f2:	d1 1c       	adc	r13, r1
			
			if(minutes > 59){
 2f4:	fc e3       	ldi	r31, 0x3C	; 60
 2f6:	cf 16       	cp	r12, r31
 2f8:	d1 04       	cpc	r13, r1
 2fa:	10 f0       	brcs	.+4      	; 0x300 <main+0x26e>
 2fc:	cc 24       	eor	r12, r12
 2fe:	dd 24       	eor	r13, r13
				minutes = 0;
			}
			
			gotoLC(2,1);
 300:	82 e0       	ldi	r24, 0x02	; 2
 302:	61 e0       	ldi	r22, 0x01	; 1
 304:	0e 94 e1 02 	call	0x5c2	; 0x5c2 <gotoLC>
			putchLCD( int_to_char(left_hours) );
 308:	8c 81       	ldd	r24, Y+4	; 0x04
 30a:	9d 81       	ldd	r25, Y+5	; 0x05
 30c:	0e 94 db 03 	call	0x7b6	; 0x7b6 <int_to_char>
 310:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <putchLCD>
			putchLCD( int_to_char(right_hours) );
 314:	c2 01       	movw	r24, r4
 316:	0e 94 db 03 	call	0x7b6	; 0x7b6 <int_to_char>
 31a:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <putchLCD>
			putchLCD(':');
 31e:	8a e3       	ldi	r24, 0x3A	; 58
 320:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <putchLCD>
			
			left_minutes = minutes / 10;
 324:	c6 01       	movw	r24, r12
 326:	6a e0       	ldi	r22, 0x0A	; 10
 328:	70 e0       	ldi	r23, 0x00	; 0
 32a:	0e 94 0d 04 	call	0x81a	; 0x81a <__udivmodhi4>
 32e:	3b 01       	movw	r6, r22
			right_minutes = minutes % 10;
 330:	c6 01       	movw	r24, r12
 332:	6a e0       	ldi	r22, 0x0A	; 10
 334:	70 e0       	ldi	r23, 0x00	; 0
 336:	0e 94 0d 04 	call	0x81a	; 0x81a <__udivmodhi4>
 33a:	5c 01       	movw	r10, r24
		
			putchLCD( int_to_char(left_minutes) );
 33c:	c3 01       	movw	r24, r6
 33e:	0e 94 db 03 	call	0x7b6	; 0x7b6 <int_to_char>
 342:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <putchLCD>
			putchLCD( int_to_char(right_minutes) );
 346:	c5 01       	movw	r24, r10
 348:	0e 94 db 03 	call	0x7b6	; 0x7b6 <int_to_char>
 34c:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <putchLCD>
			putchLCD(':');
 350:	8a e3       	ldi	r24, 0x3A	; 58
 352:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <putchLCD>
			
			putchLCD('0');
 356:	80 e3       	ldi	r24, 0x30	; 48
 358:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <putchLCD>
			putchLCD('0');
 35c:	80 e3       	ldi	r24, 0x30	; 48
 35e:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <putchLCD>
			
			if(kbcode == 'B'){
 362:	02 34       	cpi	r16, 0x42	; 66
 364:	09 f4       	brne	.+2      	; 0x368 <main+0x2d6>
 366:	ca ce       	rjmp	.-620    	; 0xfc <main+0x6a>
				stare = FIRST_A_PRESS;
            kbcode = 0;
			}
			
			if(kbcode == 'A'){
 368:	01 34       	cpi	r16, 0x41	; 65
 36a:	09 f0       	breq	.+2      	; 0x36e <main+0x2dc>
 36c:	cc ce       	rjmp	.-616    	; 0x106 <main+0x74>
 36e:	83 e0       	ldi	r24, 0x03	; 3
 370:	8a 83       	std	Y+2, r24	; 0x02
 372:	c8 ce       	rjmp	.-624    	; 0x104 <main+0x72>
			}
			
			break;
		 
		 case SECOND_A_PRESS:
			gotoLC(2,1);
 374:	82 e0       	ldi	r24, 0x02	; 2
 376:	61 e0       	ldi	r22, 0x01	; 1
 378:	0e 94 e1 02 	call	0x5c2	; 0x5c2 <gotoLC>
			putchLCD( int_to_char(left_hours) );
 37c:	8c 81       	ldd	r24, Y+4	; 0x04
 37e:	9d 81       	ldd	r25, Y+5	; 0x05
 380:	0e 94 db 03 	call	0x7b6	; 0x7b6 <int_to_char>
 384:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <putchLCD>
			putchLCD( int_to_char(right_hours) );
 388:	c2 01       	movw	r24, r4
 38a:	0e 94 db 03 	call	0x7b6	; 0x7b6 <int_to_char>
 38e:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <putchLCD>
			putchLCD(':');
 392:	8a e3       	ldi	r24, 0x3A	; 58
 394:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <putchLCD>
			
			putchLCD( int_to_char(left_minutes) );
 398:	c3 01       	movw	r24, r6
 39a:	0e 94 db 03 	call	0x7b6	; 0x7b6 <int_to_char>
 39e:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <putchLCD>
			putchLCD( int_to_char(right_minutes) );
 3a2:	c5 01       	movw	r24, r10
 3a4:	0e 94 db 03 	call	0x7b6	; 0x7b6 <int_to_char>
 3a8:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <putchLCD>
			putchLCD(':');
 3ac:	8a e3       	ldi	r24, 0x3A	; 58
 3ae:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <putchLCD>
			
			putchLCD('0');
 3b2:	80 e3       	ldi	r24, 0x30	; 48
 3b4:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <putchLCD>
			putchLCD('0');
 3b8:	80 e3       	ldi	r24, 0x30	; 48
 3ba:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <putchLCD>
			
			if(kbcode == 'B'){
 3be:	02 34       	cpi	r16, 0x42	; 66
 3c0:	09 f0       	breq	.+2      	; 0x3c4 <main+0x332>
 3c2:	48 c0       	rjmp	.+144    	; 0x454 <main+0x3c2>
 3c4:	95 e0       	ldi	r25, 0x05	; 5
 3c6:	9a 83       	std	Y+2, r25	; 0x02
 3c8:	9d ce       	rjmp	.-710    	; 0x104 <main+0x72>
			}
			
			break;
			
		 case SECOND_B_PRESS:
			hours++;
 3ca:	08 94       	sec
 3cc:	e1 1c       	adc	r14, r1
 3ce:	f1 1c       	adc	r15, r1
			
			if(hours > 23){
 3d0:	e8 e1       	ldi	r30, 0x18	; 24
 3d2:	ee 16       	cp	r14, r30
 3d4:	f1 04       	cpc	r15, r1
 3d6:	10 f0       	brcs	.+4      	; 0x3dc <main+0x34a>
 3d8:	ee 24       	eor	r14, r14
 3da:	ff 24       	eor	r15, r15
				hours = 0;
			}
			
			gotoLC(2,1);
 3dc:	82 e0       	ldi	r24, 0x02	; 2
 3de:	61 e0       	ldi	r22, 0x01	; 1
 3e0:	0e 94 e1 02 	call	0x5c2	; 0x5c2 <gotoLC>
			
			left_hours = hours / 10;
 3e4:	c7 01       	movw	r24, r14
 3e6:	6a e0       	ldi	r22, 0x0A	; 10
 3e8:	70 e0       	ldi	r23, 0x00	; 0
 3ea:	0e 94 0d 04 	call	0x81a	; 0x81a <__udivmodhi4>
 3ee:	7d 83       	std	Y+5, r23	; 0x05
 3f0:	6c 83       	std	Y+4, r22	; 0x04
			
			if(left_hours == 0){
 3f2:	61 15       	cp	r22, r1
 3f4:	71 05       	cpc	r23, r1
 3f6:	21 f4       	brne	.+8      	; 0x400 <main+0x36e>
 3f8:	8a e0       	ldi	r24, 0x0A	; 10
 3fa:	90 e0       	ldi	r25, 0x00	; 0
 3fc:	9d 83       	std	Y+5, r25	; 0x05
 3fe:	8c 83       	std	Y+4, r24	; 0x04
				left_hours = SPACE_CHARACTER;
			}
					
			right_hours = hours % 10;
 400:	c7 01       	movw	r24, r14
 402:	6a e0       	ldi	r22, 0x0A	; 10
 404:	70 e0       	ldi	r23, 0x00	; 0
 406:	0e 94 0d 04 	call	0x81a	; 0x81a <__udivmodhi4>
 40a:	2c 01       	movw	r4, r24
			putchLCD( int_to_char(left_hours) );
 40c:	8c 81       	ldd	r24, Y+4	; 0x04
 40e:	9d 81       	ldd	r25, Y+5	; 0x05
 410:	0e 94 db 03 	call	0x7b6	; 0x7b6 <int_to_char>
 414:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <putchLCD>
			putchLCD( int_to_char(right_hours) );
 418:	c2 01       	movw	r24, r4
 41a:	0e 94 db 03 	call	0x7b6	; 0x7b6 <int_to_char>
 41e:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <putchLCD>
			putchLCD(':');
 422:	8a e3       	ldi	r24, 0x3A	; 58
 424:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <putchLCD>
			
			putchLCD( int_to_char(left_minutes) );
 428:	c3 01       	movw	r24, r6
 42a:	0e 94 db 03 	call	0x7b6	; 0x7b6 <int_to_char>
 42e:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <putchLCD>
			putchLCD( int_to_char(right_minutes) );
 432:	c5 01       	movw	r24, r10
 434:	0e 94 db 03 	call	0x7b6	; 0x7b6 <int_to_char>
 438:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <putchLCD>
			putchLCD(':');
 43c:	8a e3       	ldi	r24, 0x3A	; 58
 43e:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <putchLCD>
			
			putchLCD('0');
 442:	80 e3       	ldi	r24, 0x30	; 48
 444:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <putchLCD>
			putchLCD('0');
 448:	80 e3       	ldi	r24, 0x30	; 48
 44a:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <putchLCD>
			
			if(kbcode == 'B'){
 44e:	02 34       	cpi	r16, 0x42	; 66
 450:	09 f4       	brne	.+2      	; 0x454 <main+0x3c2>
 452:	58 ce       	rjmp	.-848    	; 0x104 <main+0x72>
				stare = SECOND_B_PRESS;
            kbcode = 0;
			}
			
			if(kbcode == 'A'){
 454:	01 34       	cpi	r16, 0x41	; 65
 456:	09 f0       	breq	.+2      	; 0x45a <main+0x3c8>
 458:	56 ce       	rjmp	.-852    	; 0x106 <main+0x74>
 45a:	52 ce       	rjmp	.-860    	; 0x100 <main+0x6e>
      }
      
      //consuma codul
      if(kbhit){
         kbhit=0;
         gotoLC(1,1); //seteaza cursorul pe linia 1, coloana 1          
 45c:	81 e0       	ldi	r24, 0x01	; 1
 45e:	61 e0       	ldi	r22, 0x01	; 1
 460:	0e 94 e1 02 	call	0x5c2	; 0x5c2 <gotoLC>
         putchLCD(kbcode);
 464:	89 81       	ldd	r24, Y+1	; 0x01
 466:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <putchLCD>
 46a:	09 81       	ldd	r16, Y+1	; 0x01
 46c:	1b 82       	std	Y+3, r1	; 0x03
 46e:	5d ce       	rjmp	.-838    	; 0x12a <main+0x98>

00000470 <wait>:
#define SReg 0
#define DReg 1

volatile unsigned long int delay;

void wait(unsigned long int val){
 470:	9b 01       	movw	r18, r22
 472:	ac 01       	movw	r20, r24
   for(delay=0;delay<val;delay++){}
 474:	10 92 7e 00 	sts	0x007E, r1
 478:	10 92 7f 00 	sts	0x007F, r1
 47c:	10 92 80 00 	sts	0x0080, r1
 480:	10 92 81 00 	sts	0x0081, r1
 484:	13 c0       	rjmp	.+38     	; 0x4ac <wait+0x3c>
 486:	80 91 7e 00 	lds	r24, 0x007E
 48a:	90 91 7f 00 	lds	r25, 0x007F
 48e:	a0 91 80 00 	lds	r26, 0x0080
 492:	b0 91 81 00 	lds	r27, 0x0081
 496:	01 96       	adiw	r24, 0x01	; 1
 498:	a1 1d       	adc	r26, r1
 49a:	b1 1d       	adc	r27, r1
 49c:	80 93 7e 00 	sts	0x007E, r24
 4a0:	90 93 7f 00 	sts	0x007F, r25
 4a4:	a0 93 80 00 	sts	0x0080, r26
 4a8:	b0 93 81 00 	sts	0x0081, r27
 4ac:	80 91 7e 00 	lds	r24, 0x007E
 4b0:	90 91 7f 00 	lds	r25, 0x007F
 4b4:	a0 91 80 00 	lds	r26, 0x0080
 4b8:	b0 91 81 00 	lds	r27, 0x0081
 4bc:	82 17       	cp	r24, r18
 4be:	93 07       	cpc	r25, r19
 4c0:	a4 07       	cpc	r26, r20
 4c2:	b5 07       	cpc	r27, r21
 4c4:	00 f3       	brcs	.-64     	; 0x486 <wait+0x16>
}
 4c6:	08 95       	ret

000004c8 <rd_LCDreg>:

unsigned char rd_LCDreg(unsigned char vRS){
   unsigned char data;
   
   DDRD = 0b00000000;
 4c8:	11 ba       	out	0x11, r1	; 17

   if (vRS == 0)
 4ca:	88 23       	and	r24, r24
 4cc:	11 f4       	brne	.+4      	; 0x4d2 <rd_LCDreg+0xa>
      clrbit(PORTB, RS); //RS = '0'
 4ce:	c5 98       	cbi	0x18, 5	; 24
 4d0:	01 c0       	rjmp	.+2      	; 0x4d4 <rd_LCDreg+0xc>
   else
      setbit(PORTB, RS); //RS = '1'
 4d2:	c5 9a       	sbi	0x18, 5	; 24

   setbit(PORTB, RW); //RW = '1'
 4d4:	c6 9a       	sbi	0x18, 6	; 24

   nop;
 4d6:	00 00       	nop

   setbit(PORTB, E); //E = '1'
 4d8:	c7 9a       	sbi	0x18, 7	; 24
	...

   nop; nop; nop; nop; nop;
 4e2:	00 00       	nop

   data = PIND;
 4e4:	80 b3       	in	r24, 0x10	; 16

   clrbit(PORTB, E); //E = '0'
 4e6:	c7 98       	cbi	0x18, 7	; 24
   
   nop;
 4e8:	00 00       	nop

   DDRD = 0b11111111;
 4ea:	9f ef       	ldi	r25, 0xFF	; 255
 4ec:	91 bb       	out	0x11, r25	; 17

   return data;
}
 4ee:	08 95       	ret

000004f0 <wr_LCDreg>:

void wr_LCDreg(unsigned char vRS, unsigned char data){
   
   if (vRS == 0)
 4f0:	88 23       	and	r24, r24
 4f2:	11 f4       	brne	.+4      	; 0x4f8 <wr_LCDreg+0x8>
      clrbit(PORTB, RS); //RS = '0'
 4f4:	c5 98       	cbi	0x18, 5	; 24
 4f6:	01 c0       	rjmp	.+2      	; 0x4fa <wr_LCDreg+0xa>
   else
      setbit(PORTB, RS); //RS = '1'
 4f8:	c5 9a       	sbi	0x18, 5	; 24

   clrbit(PORTB, RW); //RW = '0'
 4fa:	c6 98       	cbi	0x18, 6	; 24

   PORTD = data;
 4fc:	62 bb       	out	0x12, r22	; 18

   nop;
 4fe:	00 00       	nop

   setbit(PORTB, E); //E = '1'
 500:	c7 9a       	sbi	0x18, 7	; 24
	...

   nop; nop; nop; nop; nop;
 50a:	00 00       	nop

   clrbit(PORTB, E); //E = '0'
 50c:	c7 98       	cbi	0x18, 7	; 24
   
   nop;
 50e:	00 00       	nop
}
 510:	08 95       	ret

00000512 <ckbf>:


void ckbf(){
   
   while(rd_LCDreg(SReg) & 1<<7){}
 512:	80 e0       	ldi	r24, 0x00	; 0
 514:	0e 94 64 02 	call	0x4c8	; 0x4c8 <rd_LCDreg>
 518:	87 fd       	sbrc	r24, 7
 51a:	fb cf       	rjmp	.-10     	; 0x512 <ckbf>
}
 51c:	08 95       	ret

0000051e <initLCD>:

void initLCD(){
   ckbf();
 51e:	0e 94 89 02 	call	0x512	; 0x512 <ckbf>
   // Function set
   //bit 7 6 5 4   3 2 1 0
   //    0 0 1 DL  N F — — 
   //    0 0 1 1   1 - - -
   wr_LCDreg(IReg, 0b00111000);
 522:	80 e0       	ldi	r24, 0x00	; 0
 524:	68 e3       	ldi	r22, 0x38	; 56
 526:	0e 94 78 02 	call	0x4f0	; 0x4f0 <wr_LCDreg>

   ckbf();
 52a:	0e 94 89 02 	call	0x512	; 0x512 <ckbf>
   // Entry mode set
   //bit 7 6 5 4   3 2   1 0
   //    0 0 0 0   0 1 I/D S
   //    0 0 0 0   0 1   1 0
   wr_LCDreg(IReg, 0b00000110);
 52e:	80 e0       	ldi	r24, 0x00	; 0
 530:	66 e0       	ldi	r22, 0x06	; 6
 532:	0e 94 78 02 	call	0x4f0	; 0x4f0 <wr_LCDreg>

   ckbf();
 536:	0e 94 89 02 	call	0x512	; 0x512 <ckbf>
   // Display on/off control
   //bit 7 6 5 4   3 2 1 0
   //    0 0 0 0   1 D C B
   //    0 0 0 0   1 1 0 0
   wr_LCDreg(IReg, 0b00001100);
 53a:	80 e0       	ldi	r24, 0x00	; 0
 53c:	6c e0       	ldi	r22, 0x0C	; 12
 53e:	0e 94 78 02 	call	0x4f0	; 0x4f0 <wr_LCDreg>

   ckbf();
 542:	0e 94 89 02 	call	0x512	; 0x512 <ckbf>
   //Clear display
   //bit 7 6 5 4   3 2 1 0
   //    0 0 0 0   0 0 0 1
   wr_LCDreg(IReg, 0x01);
 546:	80 e0       	ldi	r24, 0x00	; 0
 548:	61 e0       	ldi	r22, 0x01	; 1
 54a:	0e 94 78 02 	call	0x4f0	; 0x4f0 <wr_LCDreg>
}
 54e:	08 95       	ret

00000550 <sysinit>:

void sysinit(){
   PORTB = 0b00000000;
 550:	18 ba       	out	0x18, r1	; 24
   DDRB  = 0b11100010;
 552:	82 ee       	ldi	r24, 0xE2	; 226
 554:	87 bb       	out	0x17, r24	; 23
   DDRD  = 0b11111111;
 556:	8f ef       	ldi	r24, 0xFF	; 255
 558:	81 bb       	out	0x11, r24	; 17
   PORTA = 0;
 55a:	1b ba       	out	0x1b, r1	; 27
#define DReg 1

volatile unsigned long int delay;

void wait(unsigned long int val){
   for(delay=0;delay<val;delay++){}
 55c:	10 92 7e 00 	sts	0x007E, r1
 560:	10 92 7f 00 	sts	0x007F, r1
 564:	10 92 80 00 	sts	0x0080, r1
 568:	10 92 81 00 	sts	0x0081, r1
 56c:	13 c0       	rjmp	.+38     	; 0x594 <sysinit+0x44>
 56e:	80 91 7e 00 	lds	r24, 0x007E
 572:	90 91 7f 00 	lds	r25, 0x007F
 576:	a0 91 80 00 	lds	r26, 0x0080
 57a:	b0 91 81 00 	lds	r27, 0x0081
 57e:	01 96       	adiw	r24, 0x01	; 1
 580:	a1 1d       	adc	r26, r1
 582:	b1 1d       	adc	r27, r1
 584:	80 93 7e 00 	sts	0x007E, r24
 588:	90 93 7f 00 	sts	0x007F, r25
 58c:	a0 93 80 00 	sts	0x0080, r26
 590:	b0 93 81 00 	sts	0x0081, r27
 594:	80 91 7e 00 	lds	r24, 0x007E
 598:	90 91 7f 00 	lds	r25, 0x007F
 59c:	a0 91 80 00 	lds	r26, 0x0080
 5a0:	b0 91 81 00 	lds	r27, 0x0081
 5a4:	80 5c       	subi	r24, 0xC0	; 192
 5a6:	94 4d       	sbci	r25, 0xD4	; 212
 5a8:	a1 40       	sbci	r26, 0x01	; 1
 5aa:	b0 40       	sbci	r27, 0x00	; 0
 5ac:	00 f3       	brcs	.-64     	; 0x56e <sysinit+0x1e>
   PORTB = 0b00000000;
   DDRB  = 0b11100010;
   DDRD  = 0b11111111;
   PORTA = 0;
   wait(120000UL);
   initLCD();
 5ae:	0e 94 8f 02 	call	0x51e	; 0x51e <initLCD>
}
 5b2:	08 95       	ret

000005b4 <clrLCD>:
}
*/

//Pasul 3
void clrLCD(){
   ckbf();
 5b4:	0e 94 89 02 	call	0x512	; 0x512 <ckbf>
   //Clear display
   //bit 7 6 5 4   3 2 1 0
   //    0 0 0 0   0 0 0 1
   wr_LCDreg(IReg, 0x01);
 5b8:	80 e0       	ldi	r24, 0x00	; 0
 5ba:	61 e0       	ldi	r22, 0x01	; 1
 5bc:	0e 94 78 02 	call	0x4f0	; 0x4f0 <wr_LCDreg>
}
 5c0:	08 95       	ret

000005c2 <gotoLC>:

//Pasul 4
void gotoLC(unsigned char line, unsigned char col){
 5c2:	1f 93       	push	r17
 5c4:	16 2f       	mov	r17, r22
   unsigned char position = 0;

   if(line == 1 && col < 17){
 5c6:	81 30       	cpi	r24, 0x01	; 1
 5c8:	39 f4       	brne	.+14     	; 0x5d8 <gotoLC+0x16>
 5ca:	61 31       	cpi	r22, 0x11	; 17
 5cc:	88 f4       	brcc	.+34     	; 0x5f0 <gotoLC+0x2e>
      position |= 1<<7;
      position |= col - 1;

      ckbf();
 5ce:	0e 94 89 02 	call	0x512	; 0x512 <ckbf>
      // Set DDRAM address
      //bit 7   6   5   4     3   2   1   0
      //    1 ADD ADD ADD   ADD ADD ADD ADD
      //    1   0   0   0   col col col col
      wr_LCDreg(IReg, position);
 5d2:	11 50       	subi	r17, 0x01	; 1
 5d4:	10 68       	ori	r17, 0x80	; 128
 5d6:	08 c0       	rjmp	.+16     	; 0x5e8 <gotoLC+0x26>
   }
   else if(line == 2 && col < 17){
 5d8:	82 30       	cpi	r24, 0x02	; 2
 5da:	51 f4       	brne	.+20     	; 0x5f0 <gotoLC+0x2e>
 5dc:	61 31       	cpi	r22, 0x11	; 17
 5de:	40 f4       	brcc	.+16     	; 0x5f0 <gotoLC+0x2e>
      position |= 1<<6 | 1<<7;
      position |= col - 1;

      ckbf();
 5e0:	0e 94 89 02 	call	0x512	; 0x512 <ckbf>
      // Set DDRAM address
      //bit 7   6   5   4     3   2   1   0
      //    1 ADD ADD ADD   ADD ADD ADD ADD
      //    1   1   0   0   col col col col
      wr_LCDreg(IReg, position);
 5e4:	11 50       	subi	r17, 0x01	; 1
 5e6:	10 6c       	ori	r17, 0xC0	; 192
 5e8:	80 e0       	ldi	r24, 0x00	; 0
 5ea:	61 2f       	mov	r22, r17
 5ec:	0e 94 78 02 	call	0x4f0	; 0x4f0 <wr_LCDreg>
   }
}
 5f0:	1f 91       	pop	r17
 5f2:	08 95       	ret

000005f4 <putchLCD>:
   wait(120000UL);
   initLCD();
}

//Pasul 1
void putchLCD( char ch){
 5f4:	1f 93       	push	r17
 5f6:	18 2f       	mov	r17, r24
   ckbf();
 5f8:	0e 94 89 02 	call	0x512	; 0x512 <ckbf>
   wr_LCDreg(DReg, ch);
 5fc:	81 e0       	ldi	r24, 0x01	; 1
 5fe:	61 2f       	mov	r22, r17
 600:	0e 94 78 02 	call	0x4f0	; 0x4f0 <wr_LCDreg>

   ckbf();
 604:	0e 94 89 02 	call	0x512	; 0x512 <ckbf>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
 608:	85 e1       	ldi	r24, 0x15	; 21
 60a:	8a 95       	dec	r24
 60c:	f1 f7       	brne	.-4      	; 0x60a <putchLCD+0x16>
   _delay_us(8);

   //0x10 == 16
   if(rd_LCDreg(SReg) == 0x10)
 60e:	80 e0       	ldi	r24, 0x00	; 0
 610:	0e 94 64 02 	call	0x4c8	; 0x4c8 <rd_LCDreg>
 614:	80 31       	cpi	r24, 0x10	; 16
 616:	21 f4       	brne	.+8      	; 0x620 <putchLCD+0x2c>
      gotoLC(2,1);
 618:	82 e0       	ldi	r24, 0x02	; 2
 61a:	61 e0       	ldi	r22, 0x01	; 1
 61c:	0e 94 e1 02 	call	0x5c2	; 0x5c2 <gotoLC>

   //0x50 == 80
   if(rd_LCDreg(SReg) == 0x50)
 620:	80 e0       	ldi	r24, 0x00	; 0
 622:	0e 94 64 02 	call	0x4c8	; 0x4c8 <rd_LCDreg>
 626:	80 35       	cpi	r24, 0x50	; 80
 628:	21 f4       	brne	.+8      	; 0x632 <putchLCD+0x3e>
      gotoLC(1,1);
 62a:	81 e0       	ldi	r24, 0x01	; 1
 62c:	61 e0       	ldi	r22, 0x01	; 1
 62e:	0e 94 e1 02 	call	0x5c2	; 0x5c2 <gotoLC>
}
 632:	1f 91       	pop	r17
 634:	08 95       	ret

00000636 <putsLCD>:
      wr_LCDreg(IReg, position);
   }
}

//Pasul 5: Wrap
void putsLCD( char* ch){
 636:	1f 93       	push	r17
 638:	cf 93       	push	r28
 63a:	df 93       	push	r29
 63c:	ec 01       	movw	r28, r24
 63e:	15 e1       	ldi	r17, 0x15	; 21
 640:	1e c0       	rjmp	.+60     	; 0x67e <putsLCD+0x48>
   while(*ch){
      ckbf();
 642:	0e 94 89 02 	call	0x512	; 0x512 <ckbf>
      wr_LCDreg(DReg, *ch++);
 646:	81 e0       	ldi	r24, 0x01	; 1
 648:	68 81       	ld	r22, Y
 64a:	0e 94 78 02 	call	0x4f0	; 0x4f0 <wr_LCDreg>
      
      ckbf();
 64e:	0e 94 89 02 	call	0x512	; 0x512 <ckbf>
 652:	81 2f       	mov	r24, r17
 654:	8a 95       	dec	r24
 656:	f1 f7       	brne	.-4      	; 0x654 <putsLCD+0x1e>
      _delay_us(8);

      //0x10 == 16
      if(rd_LCDreg(SReg) == 0x10)
 658:	80 e0       	ldi	r24, 0x00	; 0
 65a:	0e 94 64 02 	call	0x4c8	; 0x4c8 <rd_LCDreg>
 65e:	80 31       	cpi	r24, 0x10	; 16
 660:	21 f4       	brne	.+8      	; 0x66a <putsLCD+0x34>
         gotoLC(2,1);
 662:	82 e0       	ldi	r24, 0x02	; 2
 664:	61 e0       	ldi	r22, 0x01	; 1
 666:	0e 94 e1 02 	call	0x5c2	; 0x5c2 <gotoLC>

      //0x50 == 80
      if(rd_LCDreg(SReg) == 0x50)
 66a:	80 e0       	ldi	r24, 0x00	; 0
 66c:	0e 94 64 02 	call	0x4c8	; 0x4c8 <rd_LCDreg>
 670:	80 35       	cpi	r24, 0x50	; 80
 672:	21 f4       	brne	.+8      	; 0x67c <putsLCD+0x46>
         gotoLC(1,1);
 674:	81 e0       	ldi	r24, 0x01	; 1
 676:	61 e0       	ldi	r22, 0x01	; 1
 678:	0e 94 e1 02 	call	0x5c2	; 0x5c2 <gotoLC>

//Pasul 5: Wrap
void putsLCD( char* ch){
   while(*ch){
      ckbf();
      wr_LCDreg(DReg, *ch++);
 67c:	21 96       	adiw	r28, 0x01	; 1
   }
}

//Pasul 5: Wrap
void putsLCD( char* ch){
   while(*ch){
 67e:	88 81       	ld	r24, Y
 680:	88 23       	and	r24, r24
 682:	f9 f6       	brne	.-66     	; 0x642 <putsLCD+0xc>

      //0x50 == 80
      if(rd_LCDreg(SReg) == 0x50)
         gotoLC(1,1);
   }
}
 684:	df 91       	pop	r29
 686:	cf 91       	pop	r28
 688:	1f 91       	pop	r17
 68a:	08 95       	ret

0000068c <smiley>:

//Pasul 6: Smiley
void smiley(){
   ckbf();
 68c:	0e 94 89 02 	call	0x512	; 0x512 <ckbf>
   // Set CGRAM address
   //bit 7 6   5   4     3   2   1   0
   //    0 1 ACG ACG   ACG ACG ACG ACG
   //    0 1   0   1     0   0   0   0
   wr_LCDreg(IReg, 0b01010000);
 690:	80 e0       	ldi	r24, 0x00	; 0
 692:	60 e5       	ldi	r22, 0x50	; 80
 694:	0e 94 78 02 	call	0x4f0	; 0x4f0 <wr_LCDreg>

   ckbf();
 698:	0e 94 89 02 	call	0x512	; 0x512 <ckbf>
   wr_LCDreg(DReg, 0b01000000); //line 1
 69c:	81 e0       	ldi	r24, 0x01	; 1
 69e:	60 e4       	ldi	r22, 0x40	; 64
 6a0:	0e 94 78 02 	call	0x4f0	; 0x4f0 <wr_LCDreg>

   ckbf();
 6a4:	0e 94 89 02 	call	0x512	; 0x512 <ckbf>
   wr_LCDreg(DReg, 0b01001010); //line 2
 6a8:	81 e0       	ldi	r24, 0x01	; 1
 6aa:	6a e4       	ldi	r22, 0x4A	; 74
 6ac:	0e 94 78 02 	call	0x4f0	; 0x4f0 <wr_LCDreg>

   ckbf();
 6b0:	0e 94 89 02 	call	0x512	; 0x512 <ckbf>
   wr_LCDreg(DReg, 0b01000000); //line 3
 6b4:	81 e0       	ldi	r24, 0x01	; 1
 6b6:	60 e4       	ldi	r22, 0x40	; 64
 6b8:	0e 94 78 02 	call	0x4f0	; 0x4f0 <wr_LCDreg>

   ckbf();
 6bc:	0e 94 89 02 	call	0x512	; 0x512 <ckbf>
   wr_LCDreg(DReg, 0b01000100); //line 4
 6c0:	81 e0       	ldi	r24, 0x01	; 1
 6c2:	64 e4       	ldi	r22, 0x44	; 68
 6c4:	0e 94 78 02 	call	0x4f0	; 0x4f0 <wr_LCDreg>

   ckbf();
 6c8:	0e 94 89 02 	call	0x512	; 0x512 <ckbf>
   wr_LCDreg(DReg, 0b01010001); //line 5
 6cc:	81 e0       	ldi	r24, 0x01	; 1
 6ce:	61 e5       	ldi	r22, 0x51	; 81
 6d0:	0e 94 78 02 	call	0x4f0	; 0x4f0 <wr_LCDreg>

   ckbf();
 6d4:	0e 94 89 02 	call	0x512	; 0x512 <ckbf>
   wr_LCDreg(DReg, 0b01001110); //line 6
 6d8:	81 e0       	ldi	r24, 0x01	; 1
 6da:	6e e4       	ldi	r22, 0x4E	; 78
 6dc:	0e 94 78 02 	call	0x4f0	; 0x4f0 <wr_LCDreg>

   ckbf();
 6e0:	0e 94 89 02 	call	0x512	; 0x512 <ckbf>
   wr_LCDreg(DReg, 0b01000000); //line 7
 6e4:	81 e0       	ldi	r24, 0x01	; 1
 6e6:	60 e4       	ldi	r22, 0x40	; 64
 6e8:	0e 94 78 02 	call	0x4f0	; 0x4f0 <wr_LCDreg>

   ckbf();
 6ec:	0e 94 89 02 	call	0x512	; 0x512 <ckbf>
   wr_LCDreg(DReg, 0b01000000); //line 8
 6f0:	81 e0       	ldi	r24, 0x01	; 1
 6f2:	60 e4       	ldi	r22, 0x40	; 64
 6f4:	0e 94 78 02 	call	0x4f0	; 0x4f0 <wr_LCDreg>
}
 6f8:	08 95       	ret

000006fa <kbscan>:

char kbscan(){
 6fa:	df 93       	push	r29
 6fc:	cf 93       	push	r28
 6fe:	cd b7       	in	r28, 0x3d	; 61
 700:	de b7       	in	r29, 0x3e	; 62
 702:	61 97       	sbiw	r28, 0x11	; 17
 704:	0f b6       	in	r0, 0x3f	; 63
 706:	f8 94       	cli
 708:	de bf       	out	0x3e, r29	; 62
 70a:	0f be       	out	0x3f, r0	; 63
 70c:	cd bf       	out	0x3d, r28	; 61
 
   unsigned char cod_intern;
   char cod_extern;
   char tabela_trans[] = "123A456B789C*0#D";
 
   for( DDRA = 1<<4; DDRA > 0; DDRA <<=1 ) {
 70e:	80 e1       	ldi	r24, 0x10	; 16
 710:	0c c0       	rjmp	.+24     	; 0x72a <kbscan+0x30>
	...
      nop; nop; nop; nop; nop; nop;

      cols = ~PINA;
 71e:	29 b3       	in	r18, 0x19	; 25
 720:	20 95       	com	r18

      cols &= 0x0f;
 722:	2f 70       	andi	r18, 0x0F	; 15

      if (cols != 0)
 724:	51 f4       	brne	.+20     	; 0x73a <kbscan+0x40>
 
   unsigned char cod_intern;
   char cod_extern;
   char tabela_trans[] = "123A456B789C*0#D";
 
   for( DDRA = 1<<4; DDRA > 0; DDRA <<=1 ) {
 726:	8a b3       	in	r24, 0x1a	; 26
 728:	88 0f       	add	r24, r24
 72a:	8a bb       	out	0x1a, r24	; 26
 72c:	8a b3       	in	r24, 0x1a	; 26
 72e:	88 23       	and	r24, r24
 730:	81 f7       	brne	.-32     	; 0x712 <kbscan+0x18>
      if (cols != 0)
         break;
   }//end for

   if (cols == 0){
      PORTB &= 0<<1;
 732:	88 b3       	in	r24, 0x18	; 24
 734:	18 ba       	out	0x18, r1	; 24
 736:	8f e7       	ldi	r24, 0x7F	; 127
 738:	35 c0       	rjmp	.+106    	; 0x7a4 <kbscan+0xaa>
      return NOKEY;
   }

   temp = DDRA;
 73a:	3a b3       	in	r19, 0x1a	; 26

   if (temp & 1<<4)
 73c:	83 2f       	mov	r24, r19
 73e:	90 e0       	ldi	r25, 0x00	; 0
      lia = 0;

   if (temp & 1<<5)
      lia = 1;

   if (temp & 1<<6)
 740:	36 ff       	sbrs	r19, 6
 742:	02 c0       	rjmp	.+4      	; 0x748 <kbscan+0x4e>
 744:	92 e0       	ldi	r25, 0x02	; 2
 746:	07 c0       	rjmp	.+14     	; 0x756 <kbscan+0x5c>
 748:	45 e0       	ldi	r20, 0x05	; 5
 74a:	96 95       	lsr	r25
 74c:	87 95       	ror	r24
 74e:	4a 95       	dec	r20
 750:	e1 f7       	brne	.-8      	; 0x74a <kbscan+0x50>
 752:	98 2f       	mov	r25, r24
 754:	91 70       	andi	r25, 0x01	; 1
      lia = 2;

   if (temp & 1<<7)
 756:	37 fd       	sbrc	r19, 7
 758:	93 e0       	ldi	r25, 0x03	; 3
      lia = 3;

   if (cols & 1<<0){
 75a:	20 fd       	sbrc	r18, 0
 75c:	0c c0       	rjmp	.+24     	; 0x776 <kbscan+0x7c>
      cola = 0;
   }
   else if (cols & 1<<1){
 75e:	21 ff       	sbrs	r18, 1
 760:	02 c0       	rjmp	.+4      	; 0x766 <kbscan+0x6c>
 762:	21 e0       	ldi	r18, 0x01	; 1
 764:	09 c0       	rjmp	.+18     	; 0x778 <kbscan+0x7e>
      cola = 1;
   }
   else if (cols & 1<<2){
 766:	22 ff       	sbrs	r18, 2
 768:	02 c0       	rjmp	.+4      	; 0x76e <kbscan+0x74>
 76a:	22 e0       	ldi	r18, 0x02	; 2
 76c:	05 c0       	rjmp	.+10     	; 0x778 <kbscan+0x7e>
      cola = 2;
   }
   else if (cols & 1<<3){
 76e:	23 ff       	sbrs	r18, 3
 770:	02 c0       	rjmp	.+4      	; 0x776 <kbscan+0x7c>
 772:	23 e0       	ldi	r18, 0x03	; 3
 774:	01 c0       	rjmp	.+2      	; 0x778 <kbscan+0x7e>
 776:	20 e0       	ldi	r18, 0x00	; 0
   unsigned char lia=0;  //linia activa
   unsigned char cola=0; //coloana activa 
 
   unsigned char cod_intern;
   char cod_extern;
   char tabela_trans[] = "123A456B789C*0#D";
 778:	de 01       	movw	r26, r28
 77a:	11 96       	adiw	r26, 0x01	; 1
 77c:	ed e6       	ldi	r30, 0x6D	; 109
 77e:	f0 e0       	ldi	r31, 0x00	; 0
 780:	81 e1       	ldi	r24, 0x11	; 17
 782:	01 90       	ld	r0, Z+
 784:	0d 92       	st	X+, r0
 786:	81 50       	subi	r24, 0x01	; 1
 788:	e1 f7       	brne	.-8      	; 0x782 <kbscan+0x88>
      cola = 3;
   }

   cod_intern = lia * 4 + cola;

   cod_extern = tabela_trans[cod_intern];
 78a:	99 0f       	add	r25, r25
 78c:	99 0f       	add	r25, r25
 78e:	92 0f       	add	r25, r18
 790:	fe 01       	movw	r30, r28
 792:	e9 0f       	add	r30, r25
 794:	f1 1d       	adc	r31, r1
 796:	81 81       	ldd	r24, Z+1	; 0x01

   while(cod_extern == '*' || cod_extern == '#'){
 798:	8a 32       	cpi	r24, 0x2A	; 42
 79a:	11 f4       	brne	.+4      	; 0x7a0 <kbscan+0xa6>
      PORTB |= 0x02;
 79c:	c1 9a       	sbi	0x18, 1	; 24
 79e:	02 c0       	rjmp	.+4      	; 0x7a4 <kbscan+0xaa>

   cod_intern = lia * 4 + cola;

   cod_extern = tabela_trans[cod_intern];

   while(cod_extern == '*' || cod_extern == '#'){
 7a0:	83 32       	cpi	r24, 0x23	; 35
 7a2:	e1 f3       	breq	.-8      	; 0x79c <kbscan+0xa2>
      PORTB |= 0x02;
      return cod_extern;
   }

   return cod_extern;
}//end kbscan
 7a4:	61 96       	adiw	r28, 0x11	; 17
 7a6:	0f b6       	in	r0, 0x3f	; 63
 7a8:	f8 94       	cli
 7aa:	de bf       	out	0x3e, r29	; 62
 7ac:	0f be       	out	0x3f, r0	; 63
 7ae:	cd bf       	out	0x3d, r28	; 61
 7b0:	cf 91       	pop	r28
 7b2:	df 91       	pop	r29
 7b4:	08 95       	ret

000007b6 <int_to_char>:


char int_to_char(int digit){
   if(digit == 0)
 7b6:	00 97       	sbiw	r24, 0x00	; 0
 7b8:	11 f4       	brne	.+4      	; 0x7be <int_to_char+0x8>
 7ba:	80 e3       	ldi	r24, 0x30	; 48
 7bc:	08 95       	ret
      return 48;
    
   if(digit == 1)
 7be:	81 30       	cpi	r24, 0x01	; 1
 7c0:	91 05       	cpc	r25, r1
 7c2:	11 f4       	brne	.+4      	; 0x7c8 <int_to_char+0x12>
 7c4:	81 e3       	ldi	r24, 0x31	; 49
 7c6:	08 95       	ret
      return 49;

   if(digit == 2)
 7c8:	82 30       	cpi	r24, 0x02	; 2
 7ca:	91 05       	cpc	r25, r1
 7cc:	11 f4       	brne	.+4      	; 0x7d2 <int_to_char+0x1c>
 7ce:	82 e3       	ldi	r24, 0x32	; 50
 7d0:	08 95       	ret
      return 50;
   
   if(digit == 3)
 7d2:	83 30       	cpi	r24, 0x03	; 3
 7d4:	91 05       	cpc	r25, r1
 7d6:	11 f4       	brne	.+4      	; 0x7dc <int_to_char+0x26>
 7d8:	83 e3       	ldi	r24, 0x33	; 51
 7da:	08 95       	ret
      return 51;

   if(digit == 4)
 7dc:	84 30       	cpi	r24, 0x04	; 4
 7de:	91 05       	cpc	r25, r1
 7e0:	11 f4       	brne	.+4      	; 0x7e6 <int_to_char+0x30>
 7e2:	84 e3       	ldi	r24, 0x34	; 52
 7e4:	08 95       	ret
      return 52;
    
   if(digit == 5)
 7e6:	85 30       	cpi	r24, 0x05	; 5
 7e8:	91 05       	cpc	r25, r1
 7ea:	11 f4       	brne	.+4      	; 0x7f0 <int_to_char+0x3a>
 7ec:	85 e3       	ldi	r24, 0x35	; 53
 7ee:	08 95       	ret
      return 53;

   if(digit == 6)
 7f0:	86 30       	cpi	r24, 0x06	; 6
 7f2:	91 05       	cpc	r25, r1
 7f4:	11 f4       	brne	.+4      	; 0x7fa <int_to_char+0x44>
 7f6:	86 e3       	ldi	r24, 0x36	; 54
 7f8:	08 95       	ret
      return 54;
   
   if(digit == 7)
 7fa:	87 30       	cpi	r24, 0x07	; 7
 7fc:	91 05       	cpc	r25, r1
 7fe:	11 f4       	brne	.+4      	; 0x804 <int_to_char+0x4e>
 800:	87 e3       	ldi	r24, 0x37	; 55
 802:	08 95       	ret
      return 55;
   
   if(digit == 8)
 804:	88 30       	cpi	r24, 0x08	; 8
 806:	91 05       	cpc	r25, r1
 808:	11 f4       	brne	.+4      	; 0x80e <int_to_char+0x58>
 80a:	88 e3       	ldi	r24, 0x38	; 56
 80c:	08 95       	ret
      return 56;
   
   if(digit == 9)
 80e:	09 97       	sbiw	r24, 0x09	; 9
 810:	11 f0       	breq	.+4      	; 0x816 <int_to_char+0x60>
 812:	80 e2       	ldi	r24, 0x20	; 32
 814:	08 95       	ret
 816:	89 e3       	ldi	r24, 0x39	; 57
      return 57;

   return 32; //ASCII SPACE character, if "hours" starts with 0 in left side
}
 818:	08 95       	ret

0000081a <__udivmodhi4>:
 81a:	aa 1b       	sub	r26, r26
 81c:	bb 1b       	sub	r27, r27
 81e:	51 e1       	ldi	r21, 0x11	; 17
 820:	07 c0       	rjmp	.+14     	; 0x830 <__udivmodhi4_ep>

00000822 <__udivmodhi4_loop>:
 822:	aa 1f       	adc	r26, r26
 824:	bb 1f       	adc	r27, r27
 826:	a6 17       	cp	r26, r22
 828:	b7 07       	cpc	r27, r23
 82a:	10 f0       	brcs	.+4      	; 0x830 <__udivmodhi4_ep>
 82c:	a6 1b       	sub	r26, r22
 82e:	b7 0b       	sbc	r27, r23

00000830 <__udivmodhi4_ep>:
 830:	88 1f       	adc	r24, r24
 832:	99 1f       	adc	r25, r25
 834:	5a 95       	dec	r21
 836:	a9 f7       	brne	.-22     	; 0x822 <__udivmodhi4_loop>
 838:	80 95       	com	r24
 83a:	90 95       	com	r25
 83c:	bc 01       	movw	r22, r24
 83e:	cd 01       	movw	r24, r26
 840:	08 95       	ret

00000842 <_exit>:
 842:	f8 94       	cli

00000844 <__stop_program>:
 844:	ff cf       	rjmp	.-2      	; 0x844 <__stop_program>
